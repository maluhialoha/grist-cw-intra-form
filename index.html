<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Grist Custom Widget</title>
  <script src="https://docs.getgrist.com/grist-plugin-api.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
      background: #ffffff;
      padding: 24px;
      color: #37352f;
    }

    .container {
      max-width: 600px;
      margin: 0 auto;
      position: relative;
    }

    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: white;
      z-index: 2000;
    }

    .modal.show {
      display: block;
    }

    .modal-content {
      height: 100%;
      display: flex;
      flex-direction: column;
      padding: 24px;
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 24px;
      padding-bottom: 16px;
      border-bottom: 1px solid #e0e0e0;
    }

    .modal-header h2 {
      font-size: 20px;
      font-weight: 600;
    }

    .close-btn {
      background: none;
      border: none;
      font-size: 28px;
      cursor: pointer;
      color: #999;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .close-btn:hover {
      background: #f0f0f0;
      border-radius: 4px;
    }

    .modal-body {
      flex: 1;
      overflow-y: auto;
      margin-bottom: 24px;
    }

    .element-item {
      padding: 12px;
      border: 1px solid #e0e0e0;
      border-radius: 4px;
      margin-bottom: 12px;
      background: #f9f9f9;
    }

    .element-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .element-type {
      font-size: 12px;
      color: #666;
      font-weight: 500;
      text-transform: uppercase;
    }

    .element-controls {
      display: flex;
      gap: 8px;
    }

    .element-controls button {
      background: white;
      border: 1px solid #e0e0e0;
      cursor: pointer;
      font-size: 16px;
      padding: 4px 8px;
      border-radius: 4px;
    }

    .element-controls button:hover {
      background: #f0f0f0;
    }

    .element-content {
      font-size: 14px;
      color: #37352f;
      margin-bottom: 8px;
    }

    .element-field-label {
      font-size: 12px;
      color: #999;
      margin-top: 4px;
    }

    .field-label-input {
      width: 100%;
      padding: 6px 8px;
      font-size: 13px;
      border: 1px solid #e0e0e0;
      border-radius: 3px;
      margin-top: 8px;
    }

    .add-section {
      display: flex;
      gap: 12px;
      align-items: flex-start;
      padding: 16px;
      background: #f9f9f9;
      border-radius: 4px;
      border: 1px solid #e0e0e0;
    }

    .add-section-fields {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .add-element-btn {
      padding: 10px 16px;
      background: #2383e2;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      white-space: nowrap;
    }

    .add-element-btn:hover {
      background: #1a6bb8;
    }

    .element-input {
      width: 100%;
      padding: 8px 12px;
      border: 1px solid #e0e0e0;
      border-radius: 4px;
      font-size: 14px;
    }

    .field {
      margin-bottom: 20px;
    }

    .field.checkbox-field {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .field.checkbox-field label {
      margin-bottom: 0;
    }

    label {
      display: block;
      font-size: 14px;
      font-weight: 500;
      margin-bottom: 8px;
      color: #37352f;
    }

    input,
    select {
      width: 100%;
      padding: 10px 12px;
      font-size: 14px;
      border: 1px solid #e0e0e0;
      border-radius: 4px;
      background: #ffffff;
      color: #37352f;
      transition: border-color 0.2s;
    }

    input.error,
    select.error {
      border-color: #d32f2f;
    }

    .error-message {
      color: #d32f2f;
      font-size: 12px;
      margin-top: 4px;
      display: none;
    }

    .error-message.show {
      display: block;
    }

    input:focus,
    select:focus {
      outline: none;
      border-color: #2383e2;
    }

    input[type="checkbox"] {
      width: auto;
      margin: 0;
    }

    input[type="date"] {
      width: 100%;
      padding: 10px 12px;
      font-size: 14px;
      border: 1px solid #e0e0e0;
      border-radius: 4px;
      background: #ffffff;
      color: #37352f;
      transition: border-color 0.2s;
    }

    select[multiple] {
      min-height: 120px;
      padding: 8px;
    }

    select[multiple] option {
      padding: 6px 8px;
      border-radius: 3px;
      margin: 2px 0;
    }

    select[multiple] option:checked {
      background: #2383e2;
      color: white;
    }

    .btn {
      background: #2383e2;
      color: white;
      border: none;
      padding: 12px 20px;
      font-size: 14px;
      font-weight: 500;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.2s;
      margin-top: 10px;
      width: 100%;
    }

    .btn:hover {
      background: #1a6bb8;
    }

    .btn:active {
      transform: translateY(1px);
    }

    .separator {
      height: 1px;
      background: #e0e0e0;
      margin: 24px 0;
    }

    .custom-title {
      font-size: 18px;
      font-weight: 600;
      margin: 20px 0 12px 0;
      color: #37352f;
    }

    .custom-text {
      font-size: 14px;
      color: #666;
      margin: 12px 0;
      line-height: 1.5;
    }
  </style>
</head>
<body>
  <div class="modal" id="configModal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>Configuration du formulaire</h2>
        <button class="close-btn" id="closeModal">&times;</button>
      </div>
      
      <div class="modal-body">
        <button class="add-element-btn" id="resetBtn" style="margin-bottom: 20px; width: 100%;">
          ðŸ”„ RÃ©initialiser avec les colonnes de la table
        </button>
        <div id="allElements"></div>
      </div>
      
      <div class="add-section">
        <div class="add-section-fields">
          <select id="elementType" class="element-input">
            <option value="">-- Type d'Ã©lÃ©ment --</option>
            <option value="separator">SÃ©parateur</option>
            <option value="title">Titre</option>
            <option value="text">Texte</option>
          </select>
          
          <input type="text" id="elementContent" class="element-input" placeholder="Contenu (titre ou texte)" style="display: none;">
        </div>
        <button class="add-element-btn" id="addElementBtn">Ajouter</button>
      </div>
    </div>
  </div>

  <div class="container">
    <div id="fields"></div>
    <button class="btn" id="addBtn">Ajouter</button>
  </div>

  <script>
    // Attendre que le DOM soit complÃ¨tement chargÃ©
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initGrist);
    } else {
      initGrist();
    }

    function initGrist() {
      console.log('Initialisation Grist...');
      
      // Configuration avec onEditOptions
      grist.ready({ 
        requiredAccess: 'full',
        onEditOptions: function() {
          configModal.classList.add('show');
        }
      });
      
      console.log('Grist ready appelÃ©');
    }

    const fieldsContainer = document.getElementById('fields');
    const addButton = document.getElementById('addBtn');
    const configModal = document.getElementById('configModal');
    const closeModal = document.getElementById('closeModal');
    const elementType = document.getElementById('elementType');
    const elementContent = document.getElementById('elementContent');
    const addElementBtn = document.getElementById('addElementBtn');
    const allElementsContainer = document.getElementById('allElements');
    const resetBtn = document.getElementById('resetBtn');
    
    let columns = [];
    let columnMetadata = {};
    let formElements = [];

    // RÃ©initialiser avec les colonnes
    resetBtn.addEventListener('click', async () => {
      if (confirm('RÃ©initialiser le formulaire avec toutes les colonnes de la table ?')) {
        formElements = columns.map(col => ({
          type: 'field',
          fieldName: col,
          fieldLabel: col
        }));
        await saveConfiguration();
        renderConfigList();
        renderForm();
        alert('Formulaire rÃ©initialisÃ© avec succÃ¨s !');
      }
    });

    // Charger la configuration
    async function loadConfiguration() {
      console.log('ðŸ“‹ DÃ©but loadConfiguration');
      try {
        console.log('Colonnes disponibles:', columns);
        const options = await grist.getOptions();
        console.log('Options rÃ©cupÃ©rÃ©es:', options);
        
        formElements = options.formElements || [];
        console.log('formElements:', formElements);
        
        // VÃ©rifier quelles colonnes sont dÃ©jÃ  dans formElements
        const existingFields = formElements
          .filter(el => el.type === 'field')
          .map(el => el.fieldName);
        
        console.log('Champs existants:', existingFields);
        
        // Ajouter les colonnes manquantes
        const missingColumns = columns.filter(col => !existingFields.includes(col));
        console.log('Colonnes manquantes:', missingColumns);
        
        if (missingColumns.length > 0) {
          // Ajouter les colonnes manquantes au dÃ©but
          const newFields = missingColumns.map(col => ({
            type: 'field',
            fieldName: col,
            fieldLabel: col
          }));
          
          formElements = [...newFields, ...formElements];
          console.log('âœ… Colonnes manquantes ajoutÃ©es au dÃ©but');
          
          // Sauvegarder automatiquement
          await saveConfiguration();
        }
        
        // Si toujours vide (premiÃ¨re utilisation), initialiser avec les colonnes
        if (formElements.length === 0 && columns.length > 0) {
          formElements = columns.map(col => ({
            type: 'field',
            fieldName: col,
            fieldLabel: col
          }));
          console.log('âœ… formElements initialisÃ©s avec les colonnes');
        }
        
        console.log('Appel renderConfigList...');
        renderConfigList();
        console.log('Appel renderForm...');
        renderForm();
        console.log('âœ… Configuration chargÃ©e et rendue');
      } catch (e) {
        console.error('âŒ Erreur chargement config:', e);
      }
    }

    async function saveConfiguration() {
      try {
        await grist.setOption('formElements', formElements);
      } catch (e) {
        console.error('Erreur sauvegarde config:', e);
      }
    }

    function renderConfigList() {
      allElementsContainer.innerHTML = '';
      
      formElements.forEach((element, index) => {
        const div = document.createElement('div');
        div.className = 'element-item';
        
        const header = document.createElement('div');
        header.className = 'element-header';
        
        const type = document.createElement('div');
        type.className = 'element-type';
        
        if (element.type === 'field') {
          type.textContent = 'CHAMP';
        } else if (element.type === 'separator') {
          type.textContent = 'SÃ‰PARATEUR';
        } else if (element.type === 'title') {
          type.textContent = 'TITRE';
        } else if (element.type === 'text') {
          type.textContent = 'TEXTE';
        }
        
        const controls = document.createElement('div');
        controls.className = 'element-controls';
        
        if (index > 0) {
          const upBtn = document.createElement('button');
          upBtn.textContent = 'â†‘';
          upBtn.onclick = () => moveElement(index, -1);
          controls.appendChild(upBtn);
        }
        
        if (index < formElements.length - 1) {
          const downBtn = document.createElement('button');
          downBtn.textContent = 'â†“';
          downBtn.onclick = () => moveElement(index, 1);
          controls.appendChild(downBtn);
        }
        
        if (element.type !== 'field') {
          const deleteBtn = document.createElement('button');
          deleteBtn.textContent = 'ðŸ—‘ï¸';
          deleteBtn.onclick = () => deleteElement(index);
          controls.appendChild(deleteBtn);
        }
        
        header.appendChild(type);
        header.appendChild(controls);
        div.appendChild(header);
        
        const content = document.createElement('div');
        content.className = 'element-content';
        
        if (element.type === 'field') {
          content.textContent = `Colonne : ${element.fieldName}`;
          
          const labelDiv = document.createElement('div');
          labelDiv.className = 'element-field-label';
          labelDiv.textContent = 'Titre du champ :';
          
          const labelInput = document.createElement('input');
          labelInput.type = 'text';
          labelInput.className = 'field-label-input';
          labelInput.value = element.fieldLabel || element.fieldName;
          labelInput.placeholder = 'Titre affichÃ© dans le formulaire';
          labelInput.onchange = (e) => {
            element.fieldLabel = e.target.value;
            saveConfiguration();
            renderForm();
          };
          
          div.appendChild(content);
          div.appendChild(labelDiv);
          div.appendChild(labelInput);
        } else if (element.type !== 'separator') {
          content.textContent = element.content;
          div.appendChild(content);
        }
        
        allElementsContainer.appendChild(div);
      });
    }

    function moveElement(index, direction) {
      const newIndex = index + direction;
      if (newIndex >= 0 && newIndex < formElements.length) {
        [formElements[index], formElements[newIndex]] = 
        [formElements[newIndex], formElements[index]];
        saveConfiguration();
        renderConfigList();
        renderForm();
      }
    }

    function deleteElement(index) {
      formElements.splice(index, 1);
      saveConfiguration();
      renderConfigList();
      renderForm();
    }

    elementType.addEventListener('change', () => {
      if (elementType.value === 'separator') {
        elementContent.style.display = 'none';
      } else if (elementType.value) {
        elementContent.style.display = 'block';
        elementContent.placeholder = elementType.value === 'title' ? 'Titre' : 'Texte';
      }
    });

    addElementBtn.addEventListener('click', () => {
      const type = elementType.value;
      if (!type) return;
      
      const content = elementContent.value.trim();
      if (type !== 'separator' && !content) {
        alert('Veuillez saisir un contenu');
        return;
      }
      
      formElements.push({ type, content });
      saveConfiguration();
      renderConfigList();
      renderForm();
      
      elementType.value = '';
      elementContent.value = '';
      elementContent.style.display = 'none';
    });

    closeModal.addEventListener('click', () => {
      configModal.classList.remove('show');
    });

    configModal.addEventListener('click', (e) => {
      if (e.target === configModal) {
        configModal.classList.remove('show');
      }
    });

    async function getColumnMetadata() {
      console.log('ðŸ” DÃ©but getColumnMetadata');
      try {
        console.log('1. RÃ©cupÃ©ration de la table...');
        const table = await grist.getTable();
        console.log('2. Table rÃ©cupÃ©rÃ©e:', table);
        
        console.log('3. RÃ©cupÃ©ration du tableId...');
        const currentTableId = await table._platform.getTableId();
        console.log('4. TableId:', currentTableId);
        
        console.log('5. Fetch _grist_Tables_column...');
        const docInfo = await grist.docApi.fetchTable('_grist_Tables_column');
        console.log('6. docInfo:', docInfo);
        
        console.log('7. Fetch _grist_Tables...');
        const tablesInfo = await grist.docApi.fetchTable('_grist_Tables');
        console.log('8. tablesInfo:', tablesInfo);
        
        const metadata = {};
        
        const tableMap = {};
        tablesInfo.tableId.forEach((tableId, index) => {
          tableMap[tablesInfo.id[index]] = tableId;
        });
        
        const currentTableNumericId = tablesInfo.id[tablesInfo.tableId.indexOf(currentTableId)];
        console.log('9. currentTableNumericId:', currentTableNumericId);
        
        for (let i = 0; i < docInfo.colId.length; i++) {
          const colId = docInfo.colId[i];
          const parentTableId = docInfo.parentId[i];
          
          if (parentTableId !== currentTableNumericId) {
            continue;
          }
          
          const type = docInfo.type[i];
          const widgetOptions = docInfo.widgetOptions?.[i];
          
          let choices = null;
          let isMultiple = false;
          let refTable = null;
          let refChoices = [];
          
          if (widgetOptions) {
            try {
              const options = JSON.parse(widgetOptions);
              if (options.choices) {
                choices = options.choices;
              }
            } catch (e) {}
          }
          
          if (type.startsWith('Ref:')) {
            refTable = type.substring(4);
            isMultiple = false;
          } else if (type.startsWith('RefList:')) {
            refTable = type.substring(8);
            isMultiple = true;
          }
          
          if (refTable) {
            try {
              const refData = await grist.docApi.fetchTable(refTable);
              refChoices = refData.id.map((id, idx) => ({
                id: id,
                label: refData[Object.keys(refData).find(k => k !== 'id' && k !== 'manualSort')]?.[idx] || id
              }));
            } catch (e) {
              console.error(`Erreur rÃ©cupÃ©ration table rÃ©fÃ©rence ${refTable}:`, e);
            }
          }
          
          metadata[colId] = {
            type: type,
            choices: choices,
            isMultiple: type === 'ChoiceList' || type.startsWith('RefList:'),
            isRef: type.startsWith('Ref:') || type.startsWith('RefList:'),
            refTable: refTable,
            refChoices: refChoices,
            isBool: type === 'Bool',
            isDate: type === 'Date' || type === 'DateTime',
            isNumeric: type === 'Numeric',
            isInt: type === 'Int'
          };
        }
        
        console.log('âœ… MÃ©tadonnÃ©es rÃ©cupÃ©rÃ©es avec succÃ¨s:', metadata);
        return metadata;
      } catch (error) {
        console.error("âŒ Erreur rÃ©cupÃ©ration mÃ©tadonnÃ©es:", error);
        console.error("Stack:", error.stack);
        return {};
      }
    }

    function createInputForColumn(col, meta) {
      let inputElement;
      
      if (meta.isBool) {
        inputElement = document.createElement('input');
        inputElement.type = 'checkbox';
        inputElement.id = `input_${col}`;
        return inputElement;
      }
      
      if (meta.isDate) {
        inputElement = document.createElement('input');
        inputElement.type = 'date';
        inputElement.id = `input_${col}`;
        return inputElement;
      }
      
      if (meta.isNumeric || meta.isInt) {
        inputElement = document.createElement('input');
        inputElement.type = 'text';
        inputElement.id = `input_${col}`;
        inputElement.placeholder = meta.isInt ? 'Entier' : 'Nombre';
        return inputElement;
      }
      
      if (meta.isMultiple) {
        const select = document.createElement('select');
        select.multiple = true;
        select.id = `input_${col}`;
        
        const optionsList = meta.refChoices.length > 0 ? meta.refChoices : (meta.choices || []).map(c => ({ id: c, label: c }));
        
        optionsList.forEach(option => {
          const opt = document.createElement('option');
          opt.value = option.id;
          opt.textContent = option.label;
          select.appendChild(opt);
        });
        
        return select;
      }
      
      if ((meta.choices && meta.choices.length > 0) || (meta.isRef && meta.refChoices.length > 0)) {
        inputElement = document.createElement('select');
        inputElement.id = `input_${col}`;
        
        const emptyOption = document.createElement('option');
        emptyOption.value = '';
        emptyOption.textContent = '-- SÃ©lectionner --';
        inputElement.appendChild(emptyOption);
        
        const optionsList = meta.refChoices.length > 0 ? meta.refChoices : meta.choices.map(c => ({ id: c, label: c }));
        optionsList.forEach(option => {
          const opt = document.createElement('option');
          opt.value = option.id;
          opt.textContent = option.label;
          inputElement.appendChild(opt);
        });
        
        return inputElement;
      }
      
      inputElement = document.createElement('input');
      inputElement.type = 'text';
      inputElement.id = `input_${col}`;
      return inputElement;
    }

    function getInputValue(col, meta) {
      const input = document.getElementById(`input_${col}`);
      
      if (!input) return null;
      
      if (meta.isBool) {
        return input.checked;
      }
      
      if (meta.isMultiple) {
        const selectedOptions = Array.from(input.selectedOptions).map(opt => opt.value);
        const values = meta.isRef ? selectedOptions.map(v => parseInt(v)) : selectedOptions;
        return ["L", ...values];
      }
      
      if (meta.isRef) {
        return input.value ? parseInt(input.value) : null;
      }
      
      if (meta.isNumeric || meta.isInt) {
        return input.value ? parseFloat(input.value) : null;
      }
      
      return input.value;
    }

    function validateField(col, meta) {
      const input = document.getElementById(`input_${col}`);
      const errorMsg = document.getElementById(`error_${col}`);
      
      input.classList.remove('error');
      if (errorMsg) errorMsg.classList.remove('show');
      
      if (meta.isNumeric || meta.isInt) {
        const value = input.value.trim();
        
        if (value === '') {
          return true;
        }
        
        const numValue = parseFloat(value);
        
        if (isNaN(numValue)) {
          input.classList.add('error');
          if (errorMsg) {
            errorMsg.textContent = 'Valeur numÃ©rique requise';
            errorMsg.classList.add('show');
          }
          return false;
        }
        
        if (meta.isInt && !Number.isInteger(numValue)) {
          input.classList.add('error');
          if (errorMsg) {
            errorMsg.textContent = 'Valeur entiÃ¨re requise (pas de dÃ©cimales)';
            errorMsg.classList.add('show');
          }
          return false;
        }
      }
      
      return true;
    }

    function renderForm() {
      console.log('ðŸŽ¨ DÃ©but renderForm');
      console.log('formElements Ã  rendre:', formElements);
      console.log('columnMetadata disponible:', columnMetadata);
      
      try {
        fieldsContainer.innerHTML = '';
        console.log('fieldsContainer vidÃ©');
        
        formElements.forEach((element, index) => {
          console.log(`Rendu Ã©lÃ©ment ${index}:`, element);
          
          try {
            if (element.type === 'separator') {
              const separator = document.createElement('div');
              separator.className = 'separator';
              fieldsContainer.appendChild(separator);
              console.log('SÃ©parateur ajoutÃ©');
            } else if (element.type === 'title') {
              const title = document.createElement('div');
              title.className = 'custom-title';
              title.textContent = element.content;
              fieldsContainer.appendChild(title);
              console.log('Titre ajoutÃ©');
            } else if (element.type === 'text') {
              const text = document.createElement('div');
              text.className = 'custom-text';
              text.textContent = element.content;
              fieldsContainer.appendChild(text);
              console.log('Texte ajoutÃ©');
            } else if (element.type === 'field') {
              const col = element.fieldName;
              const meta = columnMetadata[col] || {};
              
              console.log(`CrÃ©ation champ ${col}, meta:`, meta);
              
              const fieldDiv = document.createElement('div');
              
              if (meta.isBool) {
                fieldDiv.className = 'field checkbox-field';
              } else {
                fieldDiv.className = 'field';
              }
              
              const label = document.createElement('label');
              label.textContent = element.fieldLabel || col;
              console.log(`Label crÃ©Ã©: ${label.textContent}`);
              
              const inputElement = createInputForColumn(col, meta);
              console.log(`Input crÃ©Ã© pour ${col}`);
              
              if (meta.isBool) {
                fieldDiv.appendChild(label);
                fieldDiv.appendChild(inputElement);
              } else {
                fieldDiv.appendChild(label);
                fieldDiv.appendChild(inputElement);
                
                const errorMsg = document.createElement('div');
                errorMsg.className = 'error-message';
                errorMsg.id = `error_${col}`;
                fieldDiv.appendChild(errorMsg);
              }
              
              fieldsContainer.appendChild(fieldDiv);
              console.log(`âœ… Champ ${col} ajoutÃ© au DOM`);
            }
          } catch (elemError) {
            console.error(`âŒ Erreur sur Ã©lÃ©ment ${index}:`, elemError);
            console.error('Stack:', elemError.stack);
          }
        });
        
        console.log('âœ… renderForm terminÃ©, nombre d\'Ã©lÃ©ments rendus:', fieldsContainer.children.length);
        console.log('fieldsContainer HTML (200 chars):', fieldsContainer.innerHTML.substring(0, 200));
        console.log('fieldsContainer dimensions:', {
          offsetHeight: fieldsContainer.offsetHeight,
          offsetWidth: fieldsContainer.offsetWidth,
          scrollHeight: fieldsContainer.scrollHeight
        });
      } catch (error) {
        console.error('âŒ Erreur globale dans renderForm:', error);
        console.error('Stack:', error.stack);
      }
    }

    grist.onRecords(async (table, mappings) => {
      console.log('onRecords appelÃ©', { table, mappings });
      
      if (mappings) {
        columns = Object.keys(mappings).filter(col => col !== 'id');
      } else if (table && table.length > 0) {
        columns = Object.keys(table[0]).filter(col => col !== 'id');
      } else {
        console.log('Pas de colonnes disponibles');
        return;
      }
      
      console.log('Colonnes trouvÃ©es:', columns);
      
      columnMetadata = await getColumnMetadata();
      console.log('MÃ©tadonnÃ©es chargÃ©es:', columnMetadata);
      
      await loadConfiguration();
    });

    addButton.addEventListener('click', async () => {
      let isValid = true;
      
      formElements.forEach(element => {
        if (element.type === 'field') {
          const col = element.fieldName;
          const meta = columnMetadata[col] || {};
          if (!validateField(col, meta)) {
            isValid = false;
          }
        }
      });
      
      if (!isValid) {
        return;
      }
      
      const fields = {};
      
      formElements.forEach(element => {
        if (element.type === 'field') {
          const col = element.fieldName;
          const meta = columnMetadata[col] || {};
          fields[col] = getInputValue(col, meta);
        }
      });
      
      try {
        await grist.selectedTable.create({ fields });
        
        formElements.forEach(element => {
          if (element.type === 'field') {
            const col = element.fieldName;
            const input = document.getElementById(`input_${col}`);
            const meta = columnMetadata[col] || {};
            
            if (meta.isBool) {
              input.checked = false;
            } else if (meta.isMultiple) {
              Array.from(input.options).forEach(opt => opt.selected = false);
            } else {
              input.value = '';
            }
          }
        });
      } catch (error) {
        console.error("Erreur lors de la crÃ©ation:", error);
        alert("Erreur lors de la crÃ©ation: " + error.message);
      }
    });
  </script>
</body>
</html>